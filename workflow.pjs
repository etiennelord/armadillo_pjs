/**
* The main workflow representation
*/

class Workflow {

  //////////////////////////////////////////////////////////////////////////////
  /// Variables
  public ArrayList work=new ArrayList();           //List of workflow_object
  public ArrayList work_connection=new ArrayList();//List of workflow_connector_edge
  /// Copy & Paste variables
  public ArrayList CopyPaste_selection_work=new ArrayList();           //List of workflow_object
  public ArrayList CopyPaste_selection_work_connection=new ArrayList();//List of workflow_connector_edge
  public int CopyPaste_selection_Paste_count=0;						   // For the displacement of object
  /// Selection variables
  Object selected=null;               //Selected object (workflow_connector or workflow_object)
  Boolean selectedWasConnected=false; //Just to be sure we don't loose the state of the object  
  
  //private armadillo_workflow armadillo; //pointer to the Armadillo_workflow (parent Armadillo workflow)

  //////////////////////////////////////////////////////////////////////////////
  /// Database needed variables (TO DO : Getter/ Setter)
  public int workflow_id=0;
  public String name="Current workflow";    		 //This workflow_name
  public String filename="";                         //This workflow filename
  //////////////////////////////////////////////////////////////////////////////
  /// REFERENCE Variables (for pan)
  int ref_x=0;
  int ref_y=0;
 
  
  //- Debug
  int count=0;                        //counter for edge display numbering


////////////////////////////////////////////////////////////////////////////////
/// Save and Load function

////////////////////////////////////////////////////////////////////////////////
// Some functions by Alix and Etienne for tree building

  public int get_nb_workflow_object(){
    return work.size();
  }
  public String get_workflow_object_name(int index){
    workflow_object wo =  (workflow_object)work.get(index);
    return wo.getProperties().getName();
  }
 
 public int get_nb_workflow_connector_edge(){
    return work_connection.size();
  }
  
  public String get_workflow_connector_edge_source_name(int index){
    workflow_connector_edge wce= (workflow_connector_edge)work_connection.get(index);
    return wce.source.parent.getProperties().getID();
  }
  
  public String get_workflow_connector_edge_dest_name(int index){
    workflow_connector_edge wce= (workflow_connector_edge)work_connection.get(index);
    return wce.dest.parent.getProperties().getID();
  }


  /**
   * Note: FOR THIS FUNCTION
   * Undefined == 0 value
   * @return
   */
  public ArrayList findAllUndefined() {
     Vector<workflow_properties>tmp=new Vector<workflow_properties>();
     for (workflow_object obj:work) {
         if (obj instanceof workflow_object_output_database) {
             workflow_properties prop=obj.getProperties();
             String outputType=prop.get("outputType");
             if (prop.getInt("output_"+outputType.toLowerCase()+"_id")==0) tmp.add(prop);
         }
     }
     return tmp;
 }

    public ArrayList findAllUndefinedObjects() {
      ArrayList tmp=new ArrayList();
     for (workflow_object obj:work) {
         if (isUndefined(obj)) {             
             tmp.add(obj);
         }
     }
     return tmp;
 }

  public Boolean isundefined(workflow_object obj) {
     if (obj instanceof workflow_object_output_database) {
             workflow_properties prop=obj.getProperties();             
             if (prop.getdescription().equals("undefined")) return true;
             //--otherwise, it is if no output is found... except for for object
             if (prop.getInt("output_"+prop.get("outputtype").tolowercase()+"_id")==0&&!isFor(obj))  return true;
         }
      return false;
  }

 public Boolean isFor(workflow_object obj) {
     if (obj instanceof workflow_object_output_database) {
             workflow_properties prop=obj.getProperties();
             for (Object k:prop.keySet()) {
                if (((String)k).startsWith("For_")) return true;
             }
         }
      if (obj.getProperties().isSet("ForObjectID")) {
         workflow_properties prop=obj.getProperties();
          for (Object k:prop.keySet()) {
                if (((String)k).startsWith("For_")) return true;
         }
      }
      return false;
  }

  // /**
   // * this is the main function creating the basic execution tree
   // * @return
   // */
  // public LinkedList<workflow_object> outputExecution() {
      // LinkedList<workflow_object>Execution=new LinkedList<workflow_object>();
      // //--Use the script TriTopo to find the best path to run
      // //Scripts_conversion script=new Scripts_conversion();
      // //script.TriTopo(this, Execution);      
      // return Execution;
  // }

  // /**
   // * This function will return the workflow_object attached to either the True or the False branch of a If object
   // * @param condition (either the True or False "port")
   // * @return A list of workflow_object attached to either branch or nothing if it's not a If object
   // */
  // public LinkedList<workflow_properties> getIfExecution(workflow_object obj, Boolean condition) {
      // LinkedList<workflow_object>list_of_objects=new LinkedList<workflow_object>();
      // LinkedList<workflow_properties>list_of_properties=new LinkedList<workflow_properties>();
      // //--Test if we have a If Object, return otherwise
      // if (!(obj instanceof workflow_object_if)) return list_of_properties;
      // if (condition) {
        // //--Get the first(s) child
         // for (int i=0; i<get_nb_workflow_connector_edge();i++) {
           // workflow_connector_edge edge=work_connection.get(i);
           // if (edge.source.parent==obj&&edge.source.number==workflow_object.UP) list_of_objects.add(edge.dest.parent);
           
         // }
      // } else {
         // //--Get the first(s) child
         // for (int i=0; i<get_nb_workflow_connector_edge();i++) {
           // workflow_connector_edge edge=work_connection.get(i);
           // if (edge.source.parent==obj&&edge.source.number==workflow_object.DOWN) list_of_objects.add(edge.dest.parent);
         // }
      // }
      // //--Then, find their child, etc....
      // Vector<workflow_object>tmp=new Vector<workflow_object>();
      // for (workflow_object p:list_of_objects) {         
          // findAllOutput(p,tmp);
      // }
      // //--Put in the linkedList
      // for (workflow_object p:tmp) {          
          // list_of_objects.add(p);
      // }
      // //--Get the properties
      // for (workflow_object p:list_of_objects) {
        // list_of_properties.add(p.getProperties());
      // }
      // return list_of_properties;
  // }

  // public workflow_object findBegin() {
      // for(int i=0; i<work.size();i++) {
            // workflow_object obj=work.get(i);            
            // if (obj.getProperties().get("ObjectType").equals("Begin")) {
                // //--debug println(obj.getName());
                // return obj;
            // } 
       // }
      // return null;
  // }

  // public Vector<workflow_object> findIf() {
      // Vector<workflow_object>tmp=new Vector<workflow_object>();
      // for(int i=0; i<work.size();i++) {
            // workflow_object obj=work.get(i);            
            // if (obj.getProperties().get("ObjectType").equals("If")) {
                // //--debug println(obj.getName());
                // tmp.add(obj);
            // } 
       // }
      // return tmp;
  // }

  /**
   * Return the object needed for this object (parents)
   * @param obj
   * @return
   */
  public ArrayList findInput(workflow_object source) {
     ArrayList tmp=new ArrayList();
      for (int i=0; i<get_nb_workflow_connector_edge();i++) {
           workflow_connector_edge edge=work_connection.get(i);
           if (edge.dest.parent==source) tmp.add(edge.source.parent);
      }
      return tmp;
  }
 
  public ArrayList findConnectorInput(workflow_connector source) {
       ArrayList tmp=new ArrayList();
             //--Find all connection linking to the connector
              for (int i=0; i<get_nb_workflow_connector_edge();i++) {
                workflow_connector_edge edge=work_connection.get(i);
                //--Edge is connected to this connector
                //-- We add if we don't already have the parent
                if (edge.dest==source&&!tmp.contains(edge.source.parent)) {
                    tmp.add(edge.source.parent);
                }
            }
        return tmp;
  }
  
  /**
   * Return the imediate object descending from this object (children)
   * @param source
   * @return
   */
  public ArrayList findOutput(workflow_object source) {
      VArrayList tmp=new ArrayList();
      for (int i=0; i<get_nb_workflow_connector_edge();i++) {
           workflow_connector_edge edge=work_connection.get(i);
           if (edge.source.parent==source) tmp.add(edge.dest.parent);
      }
      return tmp;
  }

  /**
   * Recursive fonction to Return All object descending from this object (children)
   * @param source
   * @return
   */
  public ArrayList findAllOutput(workflow_object source, ArrayList tmp) {
      if (findOutput(source).size()==0) return tmp;            
      for (int i=0; i<get_nb_workflow_connector_edge();i++) {
           workflow_connector_edge edge=work_connection.get(i);
           if (edge.source.parent==source&&!tmp.contains(edge.dest.parent)) {
               tmp.add(edge.dest.parent);
               findAllOutput(edge.dest.parent, tmp);
           }
      }      
      return tmp;
  }

  /**
   * This reset the Program Object output
   */
  public void resetProgramOutput() {
      for (workflow_object obj:work) {
         if (obj instanceof workflow_object_output&&!(obj instanceof workflow_object_output_database)) {
             obj.getProperties().removeInput();
             obj.getProperties().removeOutput();
         }
         if (obj.getProperties().get("ObjectType").equals("Program")&&obj.getProperties().getStatus()!=RunProgram.status_done) {
             obj.getProperties().removeOutput();
         }
     }
  }

 /**
  * This is the MAIN function which update the workflow object dependance
  * Ex. obj -> obj_output_object ->...
  * TO DO: Limit to 1 by collector
  * Note: updated in July 2011 - Etienne
  */
  public Boolean updateDependance() {     
    
      for (workflow_object obj:work) {
          if (obj instanceof workflow_object_output
              ||obj instanceof workflow_object_output_database
              ||obj instanceof workflow_object_if
              ) {
              Vector<workflow_object> inputs=findInput(obj);
               if (inputs.size()>0) {
                   String type=obj.getProperties().get("outputType").toLowerCase();                                      
                   for (workflow_object o:inputs) {                   
                       int id=o.getProperties().getOutputID(type);
                       //--Handle case of concatenation (NOTE: WARNING!!! Don't work...
//                       if (obj instanceof workflow_object_output_database && o instanceof workflow_object_output_database) {
//                            // TO DO : HANDLE CONCATENATION?
//                       } else {
//                           obj.getProperties().put("output_"+type+"_id", id);
//                       }
                       obj.getProperties().put("output_"+type+"_id", id);
                    } //End for input
              }
               if (obj.getProperties().get("ObjectType").equals("OutputDatabase")||obj.getProperties().get("ObjectType").equals("Output")) {
                      String type=obj.getProperties().get("outputType");
                       int id=obj.getProperties().getOutputID(type);
                       //--This might failed ?
                       if (id!=0) {
//                           Output out=new Output();
//                           out.setType(type);
//                           Object bio=out.getBiologic();                                                     
//                           obj.getProperties().put("Description", ((Biologic)bio).getNameId(id));                          
                       }
					   if (obj.getProperties().isSet("AggregateObjectID")) {
						    if (inputs.size()==0) {
								obj.getProperties().remove("AggregateObjectID");
								obj.getProperties().put("Description","Undefined");
							}
					   }
                }
              //--Variable
               //--This is wahat make it not reliable if we run only some object
               if (obj instanceof workflow_object_variable ){
                   //Vector<workflow_object> inputs=findInput(obj);
                  //--Array for the numbering of input
                   int connector_next_indice[]={0,0,0,0};
                   //--Clear input
                   //--But first verify if the input is done...
                   //--
                   
                   if (inputs.size()>0) {
                       Boolean reset=true;
                       //--Don't update if the input is already done and don't have the output?
                       // No: done in programs instead
//                       for (workflow_object o:inputs) {
//                           if (o.getProperties().getStatus()==RunProgram.status_done) {}
//                       }
                       
                       //--Always true for now...
                       if (reset) obj.getProperties().removeInput();
                       
                       for (workflow_object o:inputs) {
                           String type=o.getProperties().get("outputType").toLowerCase();
                           int id=o.getProperties().getOutputID(type);
                           for (workflow_connector c:findConnection(o,obj)) {
                                   obj.getProperties().put("input_"+type+"_id"+c.number+(connector_next_indice[c.number]++),id);                                  
                           }
                        } //End for input
                   }
               }
               //--If
               if (obj instanceof workflow_object_if ){                 
                   //--Find input if any
                   //Vector<workflow_object> inputs=findInput(obj);
                   obj.getProperties().removeOutput();
                   obj.getProperties().removeOutputType();
                   obj.getProperties().removeInput();
//                   obj.updateConnectorType(1,"");
//                   obj.updateConnectorType(2,"");
                   if (inputs.size()>0) {
                       for (workflow_object o:inputs) {
                           String type=o.getProperties().get("outputType").toLowerCase();
                           obj.getProperties().put("Output"+o.getProperties().get("outputType"), "True");
                           obj.getProperties().put("outputType",o.getProperties().get("outputType"));     
                           //--Update the output connectors
//                           obj.updateConnectorType(1,o.getProperties().get("outputType"));
//                           obj.updateConnectorType(2,o.getProperties().get("outputType"));
//                           
                           //--This should be set in the If program...                          
                           int id=o.getProperties().getOutputID(type);
                            obj.getProperties().put("output_"+type+"_id",id);
                            obj.getProperties().put("input_"+type+"_id00",id);
                        } //End for input
                   }
               }
               
          } 
          //--Object is not a variable....
          else {            
              Vector<workflow_object> input=findInput(obj);              
              //--Array for the numbering of input
               int connector_next_indice[]={0,0,0,0};
               //--Clear input
               obj.getProperties().removeInput();
               if (input.size()>0) {
                   for (workflow_object o:input) {
                       String type=o.getProperties().get("outputType").toLowerCase();
                       int id=o.getProperties().getOutputID(type);                       
                       for (workflow_connector c:findConnection(o,obj)) {
                               obj.getProperties().put("input_"+type+"_id"+c.number+(connector_next_indice[c.number]++),id);
                               //println(o+"UpdateDependance : "+id+c);
                               //--delete next input
                               //obj.getProperties().remove("input_"+type+"_id"+c.number+(connector_next_indice[c.number]));
                       }                           
                    } //End for input
               }
          } //End else      
      } //End for workflow_object
      return true;
 }

 ArrayList findConnection(workflow_object source, workflow_object dest) {
     ArrayList tmp=new ArrayList();
     //--check if we really have an input
     if (!findInput(dest).contains(source)) return tmp;
     //--WE really have an input
     for (workflow_connector_edge e:work_connection) {
         //--We have a connection
         if (e.source.parent==source&&e.dest.parent==dest) {
            //--We add the destination
             tmp.add(e.dest);
         }
     }

     return tmp;
 }

 //////////////////////////////////////////////////////////////////////////////////
 //// DRAW ZOOM
 public void draw_zoom(int maxwidth, int maxheight, PGraphics buffers) {
 	  buffers.fill(255);	  	
	  buffers.rect(maxwidth-202,maxheight-152,200,150);
	  buffers.stroke(70);
	  buffers.strokeWeight(0.5f);
      buffers.line(maxwidth-200,maxheight-150, maxwidth, maxheight-150);
	  buffers.line(maxwidth-200,maxheight-150,maxwidth-200, maxheight);    
	 buffers.fill(128);
	  buffers.stroke(0);
	buffers.strokeWeight(0.2f);
	
	//console.log(factor_x+" "+factor_y);
	for (int i=0;i<work.size(); i++) {
              workflow_object tmp=(workflow_object)work.get(i);
			  int x=tmp.x-ref_x;
			  int y=tmp.y-ref_y;
		buffers.rect(zoom_window_start_x+(x/factor_x), zoom_window_start_y+(y/factor_y),10,5);					
	}
	buffers.noFill();
	buffers.rect(zoom_window_start_x-(ref_x/factor_x),zoom_window_start_y-(ref_y/factor_y),maxwidth/factor_x, maxheight/factor_y);
	
	
 }
 
// ////////////////////////////////////////////////////////////////////////////////
// /// Main Drawing routine

  public void draw() {      
    //--Draw in vector mode if it's set or if we are in low res. and moving...
	
	  if (simplegraph) {
	  
			draw_simplegraph();
		} else if (buffers==null) {			
			draw_normal();
		} else {
			draw_buffers(buffers);
		}	
	//||movingFlag
 
  }

  public void draw_simplegraph() {
      for (int i=0; i<work_connection.size();i++) {
        workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        con.drawSimpleFeature();
      }

     //-- Draw selected connector if moving (workflow_connector)
     if (selected!=null&&selected instanceof workflow_connector) {
               workflow_connector tmp=(workflow_connector)selected;
               stroke(192);
               strokeWeight(2.0f);
               // -- Debug
               // line(tmp.x+5, tmp.y+5, mouseX, mouseY);
              drawBigArrow(tmp.x+5, tmp.y+5, mouseX, mouseY,color(192), color(192));

     }
     if (selected!=null&&selected instanceof workflow_selection) {
         ((workflow_selection)selected).drawFeature();
     }

     //-- Draw object (workflow_object)
     for (int i=0; i<work.size();i++) {
       workflow_object tmp=(workflow_object)work.get(i);
        if (!(tmp instanceof workflow_object_aggregator)) tmp.drawSimpleFeature();
     }
  }

   public void draw_normal() {
         //-- Draw workflow_object_aggregator
     // for (int i=0; i<work.size();i++) {
       // workflow_object tmp=(workflow_object)work.get(i);
       // if (tmp instanceof workflow_object_aggregator) tmp.drawFeature();
     // }

     //-- Draw connection (workflow_connector_edge)
      for (int i=0; i<work_connection.size();i++) {
        workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        con.drawFeature();
      }

     //-- Draw selected connector if moving (workflow_connector)
     if (selected!=null&&selected instanceof workflow_connector) {
               workflow_connector tmp=(workflow_connector)selected;
               stroke(192);
               strokeWeight(2.0f);
               // -- Debug
               // line(tmp.x+5, tmp.y+5, mouseX, mouseY);
              drawBigArrow(tmp.x+5, tmp.y+5, mouseX, mouseY,color(192), color(192));

     }
     if (selected!=null&&selected instanceof workflow_selection) {
         ((workflow_selection)selected).drawFeature();
     }

     //-- Draw object (workflow_object)
     for (int i=0; i<work.size();i++) {
       workflow_object tmp=(workflow_object)work.get(i);
        if (!(tmp instanceof workflow_object_aggregator)) tmp.drawFeature();
     }
   }

   public void draw_buffers(PGraphics buffers) {
         //-- Draw workflow_object_aggregator
     for (int i=0; i<work.size();i++) {
       workflow_object tmp=(workflow_object)work.get(i);
       if (tmp instanceof workflow_object_aggregator) tmp.drawFeature_buffer(buffers);
     }

     //-- Draw connection (workflow_connector_edge)
      for (int i=0; i<work_connection.size();i++) {
        workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        con.drawFeature_buffer(buffers);
      }

     //-- Draw selected connector if moving (workflow_connector)
     if (selected!=null&&selected instanceof workflow_connector) {
               workflow_connector tmp=(workflow_connector)selected;
               buffers.stroke(192);
               buffers.strokeWeight(2.0f);			 
               // -- Debug
               //buffers.line(tmp.x+5, tmp.y+5, mouseX, mouseY);
               drawBigArrow_buffer(tmp.x+5, tmp.y+5, mouseX, mouseY,color(192), color(192), buffers);

     }
     if (selected!=null&&selected instanceof workflow_selection) {
         ((workflow_selection)selected).drawFeature_buffer(buffers);
     }

     //-- Draw object (workflow_object)
     for (int i=0; i<work.size();i++) {
       workflow_object tmp=(workflow_object)work.get(i);
        if (!(tmp instanceof workflow_object_aggregator)) tmp.drawFeature_buffer(buffers);
     }
   }
   
   public void pan_workflow(int px, int py) {
		//--record the displacement				
		int mx = -((zoom_factor-1)*maxwidth);
		int my = -((zoom_factor-1)*maxheight);		
		for (int i=0;i<work.size(); i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              tmp.featureTranslate(-ref_x,-ref_y);
         }
		   
		//console.log(mx+" "+my);
		//--Prevent moving out of box
		if (ref_x+px>0) {			
			px=0;
			ref_x=0;			
		} 		
		if (ref_y+py>0) {
			py=0;
			ref_y=0;
		}		
		if (ref_x+px<mx) {
			px=0;
			ref_x=mx;
		}
		if (ref_y+py<my) {
			py=0;
			ref_y=my;
		}
		ref_x+=px;
		ref_y+=py;
		for (int i=0;i<work.size(); i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              tmp.featureTranslate(ref_x,ref_y);
         }
		//console.log(ref_x+" "+ref_y);
		//--Move the position of each object
		//--pan_to_original location
	
		   
			force_redraw=true;
			redraw();
   }
   
   
   // public void draw_update() {
   // console.log('update');
         // //-- Draw workflow_object_aggregator
     // for (int i=0; i<work.size();i++) {
       // workflow_object tmp=(workflow_object)work.get(i);
       // if (tmp instanceof workflow_object_aggregator) tmp.drawFeature();
     // }

     // //-- Draw connection (workflow_connector_edge)
      // for (int i=0; i<work_connection.size();i++) {
        // workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        // con.drawFeature();
      // }

     // //-- Draw selected connector if moving (workflow_connector)
     // if (selected!=null&&selected instanceof workflow_connector) {
               // workflow_connector tmp=(workflow_connector)selected;
               // stroke(192);
               // strokeWeight(2.0f);
               // // -- Debug
               // // line(tmp.x+5, tmp.y+5, mouseX, mouseY);
              // drawBigArrow(tmp.x+5, tmp.y+5, mouseX, mouseY,color(192), color(192));

     // }
     // if (selected!=null&&selected instanceof workflow_selection) {
         // ((workflow_selection)selected).drawFeature();
     // }

     // //-- Draw object (workflow_object)
     // for (int i=0; i<work.size();i++) {
       // workflow_object tmp=(workflow_object)work.get(i);
        // if (!(tmp instanceof workflow_object_aggregator)) tmp.drawFeature();
     // }
   // }

 // ///////////////////////////////////////////////////////////////////////////////
 // /// Object creation - deletion into the workflow

 // /**
  // * Add an object to the work Vector before any aggregator object
  // * Note: normally called by createObject() in the main PApplet
  // * @param a (workflow_object)
  // */
  public Boolean add(workflow_object a) {
    
	//--Create an ID for this object      	 	 	 
	 a.getProperties().setID(a.toString());
	 
    // CASE 1: Aggregator, we add at the end
    // if (a instanceof workflow_object_aggregator) {
        // return work.add(a);
    // } else {
    // CASE 2: We add before the first aggregator
        //--Set good color        
		//checkforAggregation(a);
        //--Insert at the good place in the list
        // for (int i=0;i<work.size();i++) {
            // Object tmp=work.get(i);
            // if (tmp instanceof workflow_object_aggregator) {
               // // First element is aggregator? No insert before
                // if (i>0) {
                   // work.insertElementAt(a, i-1);
                   // return true;
               // } else {
               // // Else insert at first element
                  // work.insertElementAt(a, 0);
                  // return true;
               // }
            // }
        // }
        // CASE 3: No aggregator, insert at end
        return work.add(a);
    
  }

  /**
   * Add a connection between two workflow_connector
   * Note: Verify if we have already have a connection between the parent
   * Note: Also verify if connection already exists
   * Note: Also special case for If object
   * @param source
   * @param dest
   * @param desc
   */
 public Boolean addConnection(workflow_connector source, workflow_connector dest, String desc) {
     
     //--Determine if source is not a dest and dest is not a source
     //CASE 0. source or dest==null
     if (source==null) return false;
     if (dest==null) return false;
    //CASE 1. Source and Dest are output but not conditional
     if ((source.output&&dest.output)&&!(source.conditional&&dest.conditional)) return false;
     //CASE 1.1: Do not allow connection between non conditional object and conditionnal
     //Septembre 9 2010
     //if ((dest.conditional&&!source.conditional)||(source.conditional&&!dest.conditional)) return false;

    //CASE 2. Source is an output dest is not? Inverse
     if (!source.output&&dest.output) {
         return addConnection(dest, source, desc);
      }

     //--If we have no connection and its compatible add...
     if (!existsConnection(source, dest)&&isCompatible(source, dest)) {
         //source.parent.getClass()==workflow_object_output.class
         //||source.parent.getClass()==workflow_object_output_big.class||source.parent.getClass()==workflow_object_output_database.class

         //1. Is it already a object_output or we have conditional object
         // -> Then we create a connection and add it to the list
         if ((source.conditional&&dest.conditional)||source.parent instanceof workflow_object_output||source.parent instanceof workflow_object_if) {
            workflow_connector_edge tmp=new workflow_connector_edge(source, dest,desc, false);
            work_connection.add(tmp);
            //--Test if we have and IfObject
            if (dest.parent instanceof workflow_object_if) {
                //--We have one, we need to change the ouput of the outputType
                dest.parent.getProperties().put("Output"+source.parent.getProperties().get("outputType"), true);
            }
            return true;
         } else {
            //2.We need to create a new output object?
            // TO DO: Make a create object function here....
            //-- We look for name
             if (debug) println("addConnection -> creating new object");
             
             workflow_object_output o=null;
            
             String type=getCompatibleType(source, dest);
              if (debug) println("addConnection -> type: "+type);
              
              // Position
              int xx=((source.x+dest.x)/2>source.x?(source.x+dest.x)/2:source.x+50);
              int yy=((source.y+dest.y)/2>source.y?(source.y+dest.y)/2:source.y);
              
              o=createOutput_Object2(type,xx-20,yy);
              work.add(o);
              //--create a connection
              workflow_connector_edge oc=new workflow_connector_edge(source, o.returnNearestConnector(source), "", true);                    
              oc.setNotDeletabled(true);
			  this.work_connection.add(oc);
              workflow_connector_edge tmp=new workflow_connector_edge(o.connection[1], dest,desc, false);
              work_connection.add(tmp);

         }
         return true;
     }
     return false;
  }
  
 /**
  * HELPER FONCTION TO RETURN THE CONNECTOR OF A PARENT...
  * @param parentID
  * @param number
  * @return
  */
  public workflow_connector getConnector(int parentID, int number) {
      for (int i=work.size()-1; i>-1; i--) {
         workflow_object o=work.get(i); 
          workflow_properties prop=(workflow_properties)o.getProperties();		
          if (prop.getProperties_id()==parentID) {              
			  if (number>o.connection.length-1) return null;
              return o.connection[number];
          } else {
			//--Debug 			
		  }
      }
	  if (debug) println("Error workflow.getConnector:"+parentID+" "+number+" "+prop.getName()+" "+prop.getProperties_id());
      return null;
  }

  /**
   * this is the method which add a connector (edge) from source to destination
   * @param source
   * @param dest
   * @param desc
   * @param notdeletable
   */
  public void addConnector(workflow_connector source, workflow_connector dest, string desc, Boolean notdeletable) {
      workflow_connector_edge tmp=new workflow_connector_edge(source, dest,desc,notdeletable);
      work_connection.add(tmp);
  }

 /**
  * Determine if the source connector is compatible with the destination
  * Warning: don't check if the parent object are compatible....
  * Note: You can get the compatible type using getCompatibleType()
  * @param source
  * @param dest
  * @return true if compatible
  */
 Boolean isCompatible(workflow_connector source, workflow_connector dest) {   
     //--Example two tree connected to the same input
     //--Find all input for this connector
     ArrayList dest_input_objects=findConnectorInput(dest);
     //--Find source type and id
     workflow_object source_object=source.parent;
     String source_type=source_object.getProperties().get("outputType");		
	// CASE 0. Connector accept another input?
	
     //CASE 1. Source already connected to destination...    
     if (debug) println("(isCompatible) source_type:"+source_type);
     String source_Object_id=source_object.getProperties().getID();
     int source_id=source_object.getProperties().getOutputID(source_type);
     if (debug) println("(isCompatible) source_type_id:"+source_id);     
     for (workflow_object dest_input_object:dest_input_objects) {
         String dest_type=dest_input_object.getProperties().get("outputType");
         String dest_Object_id=dest_input_object.getProperties().getID();
         if (debug) println(dest_type+" "+dest_Object_id);
          int dest_id=dest_input_object.getProperties().getOutputID(source_type);
          //--Don't connect to yourself...
          if (source_type.equals(dest_type)&&source_id==dest_id&&source_Object_id.equals(dest_Object_id)) return false;
     }      
     // CASE 2. Two conditional object? (workflow_path) return true
     if (source.conditional&&dest.conditional&&source.isOutput()) {
         return true;
     }
    // CASE 3. Source can outputAll and dest can inputAll return true;
     if (source.isOutputAll()&&dest.isInputAll()) {
           return true;
     }
     if (debug) println("(isCompatible) Source output "+source.getOutput().size());
     //--Test for if, special exception...
     // CASE 4.0 - Aggregator (new)
	  if (source.parent.getProperties().get("ObjectType").equals("Output")&& 
		  dest.parent.getProperties().get("ObjectType").equals("OutputDatabase")) {
		for (String type:source.getOutput()) {                       
             if (dest.input(type)) {
				dest.parent.getProperties().put("AggregateObjectID",0);
				dest.parent.getProperties().put("Description","Aggregate");
				return true;
			 }
         } 
		 
	} 
	 // CASE 4.1 If
     if (source.parent.getProperties().get("ObjectType").equals("If")) {
         
          // CASE 4.1 Try to return the first compatible type
         //--Note: If have just one output...
         //--We have output
         if (source.parent.getProperties().Outputed().size()>0) {
             String IfOutput=source.parent.getProperties().Outputed().get(0);
             if (dest.input(IfOutput)) return true;
         }
     } else {
         // CASE 4.2 Try to return the first compatible type
         for (String type:source.getOutput()) {             
             if (debug) println("(isCompatible) Testing "+type+" is compatible "+dest.input(type));
             if (dest.input(type)) return true;
         }
     }//--End else
     if (debug) println("(isCompatible) - found nothing...");
     //--End--Probably not compatible
     return false;
 }

 /**
  * Return if a workflow_connector already ave a connection
  * @param source
  * @return
  */
 public Boolean haveConnection(workflow_connector source) {
     for (workflow_connector_edge edge:this.work_connection) {
         if (edge.dest.equals(source)) return true;     
     }
     return false;
 }

 /**
  * Return a compatible connector to attach the source in the dest object...
  * @param source
  * @param dest
  * @return a compatible connector or null if not found
  */
 public workflow_connector findCompatible(workflow_connector source, workflow_object dest) {
    //Case 0. If object
     if (source.parent instanceof workflow_object_if) {
         for (workflow_connector c:dest.connection) {
             if (debug) println("Testing compatible "+source.parent.getName()+" -> "+c.parent.getName());
             
             if (isCompatible(source, c)) {
                 if (debug) println("Compatible "+c.outputType+" - "+c.parent.getName());
                 return c;
             }
         }
    }

     //Case 1. Conditional source
     if (source.conditional) {
         for (workflow_connector c:dest.connection) {
            if (c.conditional) return c;
         }
     } else {
     //CASE 2. normal object
         for (workflow_connector c:dest.connection) {
             if (debug) println("Testing normal object "+source.parent.getName()+" -> "+c.parent.getName());
             if (isCompatible(source, c)) {
                 if (debug) println("Compatible "+c.outputType+" - "+c.parent.getName());
                 return c;
             }
         }
     }
     return null;
 }



/**
 * This find a compatible source from the source.parent to the dest
 * Note: Usefull if source can outputAll
 * Warning: No test here if the source and dest are compatible
 * @param source
 * @param dest
 * @return
 */
  public String getCompatibleType(workflow_connector source, workflow_connector dest) {          
    // CASE 1. Source outputALL
    for (String input:source.getOutput()) {
        if (dest.input(input)) return input;
    }
    return "";
  }

 /**
  * Verify if a connection already exists between two objects
  * A connection exists if:
  *     - The source and dest parent are the same
  *     - A connection already exists between the source parent->dest parent
  * @param source
  * @param dest
  * @return
  */
  private Boolean existsConnection(workflow_connector source, workflow_connector dest) {
     workflow_object source_parent=source.parent;
     workflow_object dest_parent=dest.parent;
     if (source_parent==dest_parent) return true;
     //--Verify if we already connect to this connector
     for (int i=0; i<work_connection.size();i++) {
         workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
         //CASE 0: Same source and Same connector?
         if (tmp.source==source&&tmp.dest==dest) return true;
         //CASE 1: SAME Connection exists (bidirectional)
         
         //if (tmp.source==source&&tmp.dest==dest) return true;
         //if (tmp.dest==source&&tmp.source==dest) return true;
         //CASE 2: SAME PARENT?
         if (tmp.source.parent==source_parent&&tmp.dest.parent==dest_parent) return true;
         if (tmp.source.parent==dest_parent&&tmp.dest.parent==source_parent) return true;
    }
     //CASE 3: COnnection don't exists...
     return false;
  }

 // ///////////////////////////////////////////////////////////////////////////////
 // /// DELETION

  /**
   * Handle the different deletion cae
   * @param selection
   */
  public void delete(Object o) {
      //CASE 1: We have some object
      if (o!=null) {
         if (o instanceof workflow_connector_edge) safelyDeleteConnector((workflow_connector_edge)o);
         if (o instanceof workflow_object_aggregator) safelyDeleteAggregator((workflow_object_aggregator)o); // TO DO
         if (o instanceof workflow_object) safelyDelete((workflow_object)o);
      }
//      } else {
//      //CASE 2: Any selected multiple object?
//        for (int i=work.size()-1; i>-1;i--) {
//            workflow_object tmp=(workflow_object)work.get(i);
//            if (tmp.selected) delete(tmp);
//        }
//      }
  }

  /**
   * This is the safe way to delete an Object
   * ->Select the object
   * ->deleteSelected
   * @return
   */
  public Boolean deleteSelected() {
      //-- Delete selection (because we want to delete a selected aggregator object)
      // delete(selected);
      //--Delete all selected object
      setChanged(true);
      //--Save a copy to the undo pile
      //saveToUndo("Delete selection");

      for (int i=work.size()-1;i>-1;i--) {
          workflow_object tmp=(workflow_object)work.get(i);
          if (tmp.selected) delete(tmp);
      }
      //--Delete all selected connection
      for (int i=work_connection.size()-1;i>-1;i--) {
          workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
          if (tmp.selected) delete(tmp);
      }      
       //--Update the dependance.
       this.updateDependance();
      return true;
  }

  /**
   * This safety delete a workflow_object from the workflow
   * @param o
   * @return
   */
  public Boolean safelyDelete(workflow_object o) {
      // Special case for FOR and WHILE
       //-- Delete all external connection
            RemoveAllConnection(o);            
            return(work.remove(o));
  }

  public Boolean safelyDeleteAggregator(workflow_object_aggregator o) {
         RemoveAllConnection(o);
         work.remove(o);
         resetColor();
         return true;
     }

  /**
   * This safety delete a workflow_connector_edge from the workflow
   * @param o
   * @return
   */
  public Boolean safelyDeleteConnector(workflow_connector_edge o) {
      //--Buffering of parent and dest connector
      //--And removing of selection for parent and dest connector
      // 1. Check if we can delete?
      if (  o.isNotDeletabled()) return false;
      // 2. deletable->Yes
      workflow_connector source=o.source;
      workflow_connector dest=o.dest;
      source.selected=false;
      dest.selected=false;
      dest.destination=false;
      //--Removing of object
      if (!work_connection.remove(o)) {
          if (debug) println("Unable to delete connector_edge "+o);
          return false;
      }
      //--We then verify if parent and dest have other connection
       source.selected=isConnected(source);
       dest.selected=isConnected(dest);
       //--Verify is dest is still a decreateOutput_Objectsstination node (no drawing)
       if (dest.selected) {
           dest.destination=isDestination(dest);
       }
       //--Update the workflow (handle If, etc..) - September 2011
       updateDependance();
       return true;
  }

  /**
   * Return if a connector is connected to another (or anything)
   * @param connector
   * @return true or false
   */
  public Boolean isConnected(workflow_connector connector) {
    for (int i=0; i<work_connection.size();i++) {
        workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        if (con.source==connector||con.dest==connector) return true;
     }
  return false;
 }

 public Boolean isDestination(workflow_connector connector) {
    for (int i=0; i<work_connection.size();i++) {
        workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        if (con.dest==connector) return true;
     }
  return false;
 }

  /**
   * Delete all the connection to an object
   * @param o
   * @return
   */
 public Boolean RemoveAllConnection(workflow_object o) {
    for (int i=work_connection.size()-1; i>-1;i--) {
        workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        if (con.source.parent==o||con.dest.parent==o) {
                    con.setNotDeletabled(false);
            safelyDeleteConnector(con);
        }
     }  
    return true;
 }

 // ///////////////////////////////////////////////////////////////////////////////
 // /// Mouse Movement and Connection related

 
 public Object select(int mx, int my) {
    //-- First check for Arrow (connection)
     for (int i=0; i<work_connection.size();i++) {
            workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
            //println("Connector"+tmp.getProperties().getName());
			if (tmp.inside2()) {
                //println("selected a connector "+tmp.getProperties().getName());				
				tmp.selected=true;
				selected=tmp;
				//work_connection.remove(tmp);
				//add(tmp);
                //selected=tmp;
				//console.dir(tmp);
				//console.dir(selected);
                return selected; // We don't want another selection for this mouseClicked
            }
        }
     //--Check for object
     for (int i=0;i<work.size(); i++) {
          workflow_object tmp=(workflow_object)work.get(i);
          //--Case 1. Object
          if (tmp.inside2()) {
              tmp.selected=true;
              selected=tmp;
              //workbox.setSelectedObject(tmp);
              // --Change selected object position in workflow
             //   In fact, we remove then add back the element to the list
             work.remove(tmp);
             add(tmp);
             return selected; // We don't want another selection for this mouseClicked
           }
           //--Case 2. Connection
           for (int j=0; j<tmp.connection.length;j++) {
             if (tmp.connection[j].inside2()) {
                 //selected=tmp.connection[j]; //No real selection
                 return tmp.connection[j];
             }
           }
        }
     return null; //No selection
 }

 /**
  * Create All the appropriate Output Object from a Connector (expaqnd the connection)
  * @param s
  */
 public void createOutput_Objects(workflow_connector s) {
                //TO DO: Determine is this connector is really an output
                 int nb_output=s.getOutput().size();
				 if (debug) println("createOutput_Objects for connector ");				
                 if (!s.isOutput()||nb_output==0||s.parent.getProperties().get("ObjectType").equals("Output")||s.parent.getProperties().get("ObjectType").equals("OutputDatabase")) {				
					return;
				 }
				 
                 //this.add(new workflow_aggregator_output(tmp));
                     int posy=s.parent.y-((nb_output*20)/2)+20; //Middle point
                     for (String type:s.getOutput()) {
                         Boolean found=false;						
                         //Check if output already exist for this object
                         //1						 
						 for (workflow_object w:findOutput(s.parent)) {
                             if (w.getProperties().Outputed().contains(type)) found=true;
                         }
                         //--If not found, create it...
                         if (!found) {
                             workflow_object_output o=null;    
							 if (debug) println("createOutput_Objects !found creating "+type+" "+s.x+" "+posy);
                             o=createOutput_Object2(type,s.x+50,posy);
							 posy+=20;
							  //o.getProperties().print();
                             if (o instanceof workflow_object_output_big) posy+=10;
                             o.getProperties().put("ParentID", s.parent.getProperties().getID());
							 add(o);
                            //--create a connection
                            workflow_connector_edge oc=new workflow_connector_edge(s, o.returnNearestConnector(s), "",true);
                            //oc.setNotDeletabled(true);
                            work_connection.add(oc);
                            this.updateDependance();
                         } else {
							posy+=20;
						 }
                     }               
				} //--createOutput_Objects

 /**
  * Helper function to create a workflow_object_output with correct size
  * @param s
  */
 public workflow_object_output createOutput_Object2(String outputType, int x, int y) {      			
		if (outputType.length()>10) {
            return new workflow_object_output_big(outputType, x,y);
        } else {			
            return new workflow_object_output(outputType, x,y);
		}
 }

 // /**
  // * Helper function to create a workflow_object_output with correct size
  // * @param s
  // */
 public workflow_object_output createOutput_Object(workflow_properties prop, int x, int y) {       
		//println("createOutput_Object: "+prop.getName());
		if (prop.getName().length()>10) {
            return new workflow_object_output_big(prop, x,y);
        } else {
            return new workflow_object_output(prop, x,y);
        }
 }

 // public void Undo() {
     // System.out.println("Undo: "+UndoRedo.size());
     // for (Workflows w:UndoRedo) {
         // System.out.println(w.getName());
     // }
     // if (UndoRedo.size()>0) {
        // Workflows undo=UndoRedo.getLast();
        // UndoRedo.removeLast();
        // //--Set the current workflow in txt as the current workflow
        // workbox.getCurrentWorkflows().setWorkflow_in_txt(undo.getWorkflow_in_txt());
        // workbox.getCurrentWorkflows().StringToWorkflow();
        // UndoRedo.removeLast();
     // }
 // }

 // public void ResetUndo() {
     // UndoRedo.clear();
 // }

 // private void saveToUndo(String info) {
      // //--Save a copy to the undo pile<
     // //--Note: this doesn't work for now...
// //    Workflows undo=new Workflows();
// //    undo.setWorkflow_in_txt(this.workflowToString());
// //    undo.setName(info);
// //    UndoRedo.add(undo);
     // //System.out.println("saveToUndo"+info+":"+UndoRedo.size());
     // //for (Workflows w:UndoRedo) System.out.println(w);
 // }

 public void selectAll() {
        
		for (int i=0;i<work.size(); i++) {
          //workflow_object tmp=(workflow_object)work.get(i);
		  workflow_object tmp=work.get(i);
          tmp.selected=true;
        }
		
        for (int i=0; i<work_connection.size();i++) {
            workflow_connector_edge tmp=work_connection.get(i);
            tmp.selected=true;
        }
 }

 public void selectNone() {
        for (int i=0;i<work.size(); i++) {
          workflow_object tmp=(workflow_object)work.get(i);
          tmp.selected=false;

        }
        for (int i=0; i<work_connection.size();i++) {
            workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
            tmp.selected=false;
        }
 }

  public void inverseSelection() {
        for (int i=0;i<work.size(); i++) {
          workflow_object tmp=(workflow_object)work.get(i);
          tmp.selected=!tmp.selected;

        }
        for (int i=0; i<work_connection.size();i++) {
            workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
            tmp.selected=!tmp.selected;
        }
 }


  public void move(int px, int py) {
    //--Workflow changed flag
	movingFlag=true;
      setChanged(true);
    //--Put undo
     //saveToUndo("Move ");
    //CASE 1: We already have a selection and it is a workflow_object
      if (selected!=null) {
          if (selected instanceof workflow_object) {			
			for (int i=0;i<work.size(); i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              if (tmp.selected||tmp.moving) tmp.featureTranslate(px,py);
            }
            //((workflow_object)selected).featureTranslate(px,py);
          }

          // if (selected instanceof workflow_drag_connector) {
              // workflow_object_aggregator tmp=(workflow_object_aggregator) ((workflow_drag_connector)selected).parent;
              // tmp.update(tmp.x2+px, tmp.y2+py);
          // }

          if (selected instanceof workflow_selection) {
            //--Update position
            ((workflow_selection)selected).update(mouseX, mouseY);
            //--Update selected object
            for (int i=0;i<work.size(); i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              tmp.selected=((workflow_selection)selected).inside2(tmp.x, tmp.y);
              // Debug -- println(tmp.name+" "+tmp.selected);
            }
          }
          // Note: moving of workflow_connector is done in the draw() and notMoving() fucntions;
       } else {
    ///////////////////////////////////////////////////////////////////////////
    //CASE 2.1: No selection, we look for one....in workflow_object
        //-- Set global moving flag if its a real move :)
        movingFlag=true;
        //--
        for (int i=0;i<work.size(); i++) {
          workflow_object tmp=(workflow_object)work.get(i);
           if (tmp.inside2()) {
             tmp.moving=true;
             //tmp.selected=true;
             selected=tmp;
             // --Change selected object position in workflow
             //   In fact, we remove then add back the element to the list
             //workbox.setSelectedObject(tmp);
             work.remove(tmp);
             add(tmp);
             //--Handle Aggregator selection if move
             if (selected instanceof workflow_object_aggregator) {
                 workflow_object_aggregator tmp2=(workflow_object_aggregator)selected;
                 workflow_selection select=new workflow_selection(tmp2.x1,tmp2.y1, tmp2.x2, tmp2.y2);
                  for (int k=0;k<work.size(); k++) {
                    workflow_object tmp3=(workflow_object)work.get(k);
                    tmp3.selected=select.inside2(tmp3.x, tmp3.y);
                 }
             }
             return; //Hack: We don't want another selection
           }
      //CASE 2.2: We have a connector?

          for (int j=0; j<tmp.connection.length;j++) {
             if (tmp.connection[j].inside2()) {
                 selected=tmp.connection[j];
                 tmp.connection[j].selected=true;
                 // Determine if it was connected
                 selectedWasConnected=isConnected(tmp.connection[j]);
                 return; //Hack: We don't want another selection
             }
           }

      // CASE 2.3: We have a drag object?
           if (tmp instanceof workflow_object_aggregator)
                    for (int j=0; j<((workflow_object_aggregator)tmp).drag.length;j++) {
                    if (((workflow_object_aggregator)tmp).drag[j].inside2()) {
                        selected=((workflow_object_aggregator)tmp).drag[j];
                        ((workflow_object_aggregator)tmp).drag[j].selected=true;
                         return; //Hack: We don't want another selection
                    }
                }

     
         } // End for
        //CASE 2.4: No object, no connector, selection...
        for (int i=0; i<work_connection.size();i++) {
            workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
            if (tmp.inside2()) {
                tmp.selected=true;
                selected=tmp;
                return;
            }
        }

        //CASE 2.5: Nothing? We create a selection box or drag
       if (px!=0&&py!=0) {
			selected=new workflow_selection(mouseX, mouseY);
		} 
       }
  }

  /**
   * We stop moving or deselect
   */
  public void notMoving() {
  
	//Remove highlight
  	resetHighLight();
  
    //-- Set global moving flag to false
    movingFlag=false;
   // - Debug Reset state for selected if we are not mowing
    if (selected instanceof workflow_object) {
        ((workflow_object)selected).moving=false;
         //-- Check if in one of the aggregator
        checkforAggregation(((workflow_object)selected));
    }
    if (selected instanceof workflow_drag_connector) {
        ((workflow_drag_connector)selected).selected=false;
        for (int i=0; i<work.size(); i++) {
            workflow_object tmp=(workflow_object)work.get(i);
            checkforAggregation(tmp);
        }
        
    }
    // if (selected instanceof workflow_object_aggregator) {
        // for (int i=0; i<work.size(); i++) {
            // workflow_object tmp=(workflow_object)work.get(i);
            // if (tmp.selected) checkforAggregation(tmp);
        // }
        // resetSelected();
    // }
    if (selected instanceof workflow_connector_edge) {
        // Do nothing
    }

    if (selected instanceof workflow_connector) {
        if (debug) println("Testing drop connector...");
        //CASE 1: Are we over another connector?
         // Iterate over all workflow_object and workflow_connector
         for (int i=0;i<work.size();i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              
              // CASE 1.1: Check for connector (workflow_connector) (prefered)
              workflow_connector source_connector=(workflow_connector)selected;
              workflow_connector dest_connector=tmp.returnConnector();
              if (dest_connector!=null) {
                if (debug) println("notMoving found connector -> adding connection");
                if (addConnection(source_connector, dest_connector, str(count++))) {
                        //TO DO in addConnection: dest_connector.selected=true;
                } else {
                       //TO DO: Put in the addConnection?
                       source_connector.selected=isConnected(source_connector);
                }                
                selected=null;
                return;
               }
            } //End for

         // CASE 1.2: Check for workflow_object
           //Iterate over all workflow_object and workflow_connector
           for (int i=0;i<work.size();i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              if (tmp.inside2()) {
                   if (debug) println("notMoving found workflow_object -> adding connection");
                  if (debug) println("Inside "+tmp.getName());                    
                    workflow_connector source_connector=(workflow_connector)selected;
                    workflow_connector dest_connector=findCompatible(source_connector, tmp);
                    if (addConnection(source_connector, dest_connector, str(count++))) {
                           dest_connector.selected=true;                           
                       } else {          
                            source_connector.selected=isConnected(source_connector);
                       }
                        selected=null;
                       return;
                     }
                  }//End for        
        //CASE 2: We are not over another connector or workflow_object
        workflow_connector source_connector=(workflow_connector)selected;
        source_connector.selected=isConnected(source_connector);        
    } //End wortflow_connector
    //--Added for If...
    updateDependance();
  selected=null;    
  }

  /**
   * this reset the colormode of a workflow_object an account for aggregation
   * object (for, while...)
   * @param o
   */
   public void checkforAggregation(workflow_object o) {
        // o.resetcolormode();
        // o.getproperties().remove("insidefor");
        // //--iterate over each object to find aggregator
        // //-- note: we should create a special list for them? or an index of position?
        // for (int i=0;i<work.size();i++) {
             // workflow_object tmp=(workflow_object)work.get(i);
              // if (tmp instanceof workflow_object_aggregator) {
                 // //--create a selection_object (easier to check for insideness
                  // workflow_object_aggregator tmp2=(workflow_object_aggregator)tmp;
                  // workflow_selection select=new workflow_selection(tmp2.x1,tmp2.y1, tmp2.x2, tmp2.y2);
                  // if(select.inside(o.x, o.y)) {
                      // o.setcolormode(((workflow_object_aggregator)tmp).getcolormode());
                      // o.getproperties().put("insidefor", true);
                      // return;
                  // }
              // }
        // }
   }

  // /**
   // * Find if a workflow_object is inside a Aggregator object (While, For)
   // * @param o
   // * @return True if inside an aggregator object
   // */
   // public Boolean isInsideAggregation(workflow_object o) {
        // //--Iterate over each object to find aggregator
        // //-- Note: we should create a special list for them? or an index of position?
        // for (int i=0;i<work.size();i++) {
             // workflow_object tmp=(workflow_object)work.get(i);
              // if (tmp instanceof workflow_object_aggregator) {
                 // //--Create a selection_object (easier to check for insideness
                  // workflow_object_aggregator tmp2=(workflow_object_aggregator)tmp;
                 // workflow_selection select=new workflow_selection(tmp2.x1,tmp2.y1, tmp2.x2, tmp2.y2);
                  // if(select.inside(o.x, o.y)) {
                          // return true;
                  // }
              // }
        // }
        // return false;
   // }


  
 /**
  * This reset the selection/moving state of each workflow_object
  */
  public void resetSelected() {
           //--Reset Selected Object
           for (int i=0;i<work.size();i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              tmp.selected=false;
              tmp.moving=false;
           }
           //Reset Selected Connection
           for (int i=0;i<work_connection.size();i++) {
              workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
              tmp.selected=false;
           }
          
  }
  
  public void resetState() {
        for (int i=0;i<work.size();i++) {
            workflow_object obj=(workflow_object)work.get(i);
            obj.getProperties().remove("Status");
            obj.getProperties().remove("StatusString");
            obj.getProperties().remove("IfStatus");
            obj.getProperties().remove("CommandLine_Running");                       
        }        
        redraw();
    }

	public void resetHighLight() {
        for (int i=0;i<work.size();i++) {
            workflow_object obj=(workflow_object)work.get(i);
            obj.getProperties().remove("highlight");                     
        }        
    }

	public int getNumberObjectSelected() {
		int number=0;
		 for (int i=0;i<work.size();i++) {
              workflow_object tmp=(workflow_object)work.get(i);
              if (tmp.selected) number++;
          }    
          return number;    
	}
	
	public int getNumberConnectionSelected() {
		int number=0;
		 for (int i=0;i<work_connection.size();i++) {
              workflow_connector_edge tmp=(workflow_connector_edge)work_connection.get(i);
              if (tmp.selected) number++;
          }    
          return number;    
	}

  public void resetcolor() {
      for (int i=0;i<work.size();i++) {
            workflow_object tmp=(workflow_object)work.get(i);
            if (!(tmp instanceof workflow_object_aggregator)) checkforAggregation(tmp);
      }
  }
  

  // /////////////////////////////////////////////////////////////////////////////////////////////////////
  // /// Draw Arrow -- Duplicate ot workflow_connector_edge

  public void drawArrow(float x1, float y1, float x2, float y2, int lineColor, int fillColor) {
    float angle=atan2(y2-y1,x2-x1);
    stroke(lineColor); //Line color
    fill(fillColor);   //fill color
    strokeWeight(2.0f);
    line(x1,y1,x2,y2);
    pushMatrix();
    translate(x2,y2);
    rotate(angle);
    beginShape();
      vertex(-12,-4);//Far Outside UP
      vertex(0,0);   //Middle point
      vertex(-12,4); //Far Outside Bottom
      vertex(-10,-1); //Indide Middle point
    endShape(CLOSE);
    popMatrix();
}

  public void drawBigArrow(float x1, float y1, float x2, float y2, int lineColor, int fillColor) {
    float angle=atan2(y2-y1,x2-x1);
    stroke(lineColor); //Line color
    fill(fillColor);   //fill color
    strokeWeight(5.0f);
    line(x1,y1,x2,y2);
    pushMatrix();
    translate(x2,y2);
    rotate(angle);
    beginShape();
      vertex(-15,-5);//Far Outside UP
      vertex(0,0);   //Middle point
      vertex(-15,5); //Far Outside Bottom
      vertex(-12,-1); //Indide Middle point
    endShape(CLOSE);
    popMatrix();
}

public void drawBigArrow_buffer(float x1, float y1, float x2, float y2, int lineColor, int fillColor, PGraphics buffers) {
    float angle=atan2(y2-y1,x2-x1);
    buffers.stroke(lineColor); //Line color
    buffers.fill(fillColor);   //fill color
    buffers.strokeWeight(5.0f);
    buffers.line(x1,y1,x2,y2);
    buffers.pushMatrix();
    buffers.translate(x2,y2);
    buffers.rotate(angle);
    buffers.beginShape();
      buffers.vertex(-15,-5);//Far Outside UP
      buffers.vertex(0,0);   //Middle point
      buffers.vertex(-15,5); //Far Outside Bottom
      buffers.vertex(-12,-1); //Indide Middle point
    buffers.endShape(CLOSE);
    buffers.popMatrix();
}

   /////////////////////////////////////////////////////////////////////////////////////////////////////
   /// miscellaneous Fonction -- Mostly for debug


  public void displayEdge() {
     for (int i=0; i<work_connection.size();i++) {
        workflow_connector_edge con=(workflow_connector_edge)work_connection.get(i);
        con.displayEdge=true;
     }
  }

  
     // public Boolean saveWorkflow(String filename) {
        // try {
            // PrintWriter pw=new PrintWriter(new FileWriter(new File(filename)));
            // pw.print(workflowToString());
            // pw.flush();
            // pw.close();
            // setChanged(false);
            // return true;
        // } catch(Exception e) {return false;}
    // }

    public Boolean loadWorkflow(String filename) {                        
			String[] str_buf=null;
			try {
				str_buf=loadStrings(filename);                           
			} catch(Exception e) {}
			if (str_buf==null) return false;
			String st="";
			for (String stri:str_buf) {			         
                //--Test: remove statusString, status and database information
                	//||	stri.matches("output_.*_id=.*") --was below
				
				//--Change some properties
				
				
				if (stri.matches("StatusString=.*")||
                    //stri.matches("Status=.*")||
                    stri.startsWith("#")				
                        ) {}
                else {
                    st+=stri+"\n";
                }
            }          
            return StringToWorkflow(st);       
    }

	public String workflowToStringForExport() {
        if (workflow==null) return "";
        String pw="";
				Util u=new Util();
            //df.createWorkflow(workflow); //We create a database copy to have the properties_id;
            pw+="# Armadillo workflow\n";
            pw+="# Created on "+u.returnCurrentDateAndTime()+"\n";
            int next_id=0;
			//int next_id=df.getNextPropertiesID();
            for(workflow_object obj:work) {
                //We add new properties_id
                //if (obj.getProperties().getProperties_id()==0) {
                     obj.getProperties().put("properties_id",next_id);
                     next_id++;
                //}
                pw+="Object"+"\n";
                pw+=obj.getProperties().serializeToString()+"\n";
            }
            for( workflow_connector_edge connector:work_connection) {
                pw+="Connector"+"\n";
                // # Hack to save the source and dest properties id...
                connector.getProperties().put("source_properties_id", connector.getSourceParent().getProperties().getProperties_id());
                connector.getProperties().put("dest_properties_id", connector.getDestinationParent().getProperties().getProperties_id());
                pw+=connector.getProperties().serializeToString()+"\n";
            }
            
            //--Serialize objects 
             // for(workflow_object obj:workflow.workflow.work) {
                    // if (obj instanceof workflow_object_output_database) {
                        // pw.append("Database"+"\n");
                        // String outputType=obj.getProperties().get("OutputType");
                          // Output out=new Output();
                          // out.setType(outputType);
                          // out.setTypeid(obj.getProperties().getOutputID(outputType));
                         // //--Initialize the object
                        // Object bio=out.getBiologic();
                        // //((Biologic)bio).serialize();
                    // }     
                    
            // }
            
//            pw.append(config.properties.serializeToString());
            pw+="\n";       
        //Config.log(pw.toString());
        return pw;
    }
	
	public String workflowToJSON() {
        if (workflow==null) return "";
			String pw="";
			Util u=new Util();        
			pw+="{  \"Armadillo workflow\": {";
            pw+=" \"Created on\":\""+u.returnCurrentDateAndTime()+"\"},";
            int next_id=0;
			 pw+="\"Object\":{";
			//int next_id=df.getNextPropertiesID();
            int workflow_i=work.size();
			int j=0;
			for(workflow_object obj:work) {
                //We add new properties_id
                //if (obj.getProperties().getProperties_id()==0) {
                     obj.getProperties().put("properties_id",next_id);
                     next_id++;
                //}               
                pw+=obj.getProperties().serializeToJSON()+"";				
				if (j<workflow_i-1) pw+=","; 
				j++;
            }
			pw+="},";
            pw+="\"Connector\":{";
			 int workflow_i=work_connection.size();
			 j=0;
			for( workflow_connector_edge connector:work_connection) {              
                // # Hack to save the source and dest properties id...
                connector.getProperties().put("source_properties_id", connector.getSourceParent().getProperties().getProperties_id());
                connector.getProperties().put("dest_properties_id", connector.getDestinationParent().getProperties().getProperties_id());
                pw+=connector.getProperties().serializeToJSON()+"";				
				if (j<workflow_i-1) pw+=","; 				
				j++;
            }
            pw+="}"; //--End connector
			pw+="}"; //--End JSON
			
            //--Serialize objects 
             // for(workflow_object obj:workflow.workflow.work) {
                    // if (obj instanceof workflow_object_output_database) {
                        // pw.append("Database"+"\n");
                        // String outputType=obj.getProperties().get("OutputType");
                          // Output out=new Output();
                          // out.setType(outputType);
                          // out.setTypeid(obj.getProperties().getOutputID(outputType));
                         // //--Initialize the object
                        // Object bio=out.getBiologic();
                        // //((Biologic)bio).serialize();
                    // }     
                    
            // }
            
//            pw.append(config.properties.serializeToString());
            pw+="";       
        //Config.log(pw.toString());       
		return pw;
    }
   
  
    /**
     * Load from a string a workflow
     *
     * Workflow.workflow...
     * Note: we need to check for depreciated class...
     * And inform the user...
     * @param str
     * @return
     */
     public Boolean StringToWorkflow(String str) {                 
         //--Add a ending line to be sure we process everything.
         str=str+"\n";
         //--Clear the current workflow
         //selectAll();
        // deleteSelected();
		 String st="";
            Boolean modeObject=false;   //--Current Object
            Boolean modeConnector=false;//--Connector between object (Arrow)
            Boolean modeDatabase=false; //--Data to be loaded (other properties - in developpermode only)

            //--Split Workflow by line
            String[] stri_array=str.split("\n");
            for (String stri:stri_array) {               
                //--Skip comments
                if (!stri.startsWith("#")) {
                    //--Find mode
                    if (stri.equals("Object")) modeObject=true;
                    if (stri.equals("Connector")) modeConnector=true;
                    if (stri.equals("Database")) modeDatabase=true;
                    
                    //--Process String
                    if (stri.equals("")) {
                        if (modeDatabase) {
                            modeDatabase=false;                            
                        }
                        if (modeObject) {
                            modeObject=false;                            
                            workflow_properties prop=new workflow_properties();
                            prop.deserializeFromString(st);                            
                            createObjectWorkflow(prop);
                            st="";
                        }
                        if (modeConnector) {
                            modeConnector=false;
                            workflow_properties prop=new workflow_properties();
                            prop.deserializeFromString(st);
                            int source_connectorNb=prop.getInt("source");
                            int dest_connectorNb=prop.getInt("destination");
                            int source_properties_id=prop.getInt("source_properties_id");
                            int dest_properties_id=prop.getInt("dest_properties_id");                            
                            workflow_connector source=(workflow_connector)getConnector(source_properties_id, source_connectorNb);
                            workflow_connector dest=(workflow_connector)getConnector(dest_properties_id, dest_connectorNb);
                            if (source!=null&&dest!=null) {
                                Boolean notDeletabled=false;
                                if (prop.isSet("notDeletabled")) {
									//println(prop.getBoolean("notDeletabled"));
									notDeletabled=(Boolean)prop.getBoolean("notDeletabled");
								}
                                 //println(notDeletabled);
								 addConnector(source, dest, "",notDeletabled);
                                st="";
                            } else if (debug) println("Error for Source_id: "+source_properties_id+"("+source_connectorNb+") "+"dest_id: "+dest_properties_id+"("+dest_connectorNb+")" );
                        }       
                    } else {
                            st+=stri+"\n";
                    }
                } //--End startWith #
            } //--End while br.ready
            ////////////////////////////////////////////////////////////////////
            //--Hack final add in case we are short
                if (modeObject) {
                            modeObject=false;
                            workflow_properties prop=new workflow_properties();
                            prop.deserializeFromString(st);
                            createObjectWorkflow(prop);
                            st="";
                        }
                        if (modeConnector) {
                            modeConnector=false;
                            workflow_properties prop=new workflow_properties();
                            prop.deserializeFromString(st);
                            int source_connectorNb=prop.getInt("source");
                            int dest_connectorNb=prop.getInt("destination");
                            int source_properties_id=prop.getInt("source_properties_id");
                            int dest_properties_id=prop.getInt("dest_properties_id");
                            workflow_connector source=getConnector(source_properties_id, source_connectorNb);
                            workflow_connector dest=getConnector(dest_properties_id, dest_connectorNb);
                            if (source==null||dest==null) {
                                if (debug) println("*** Error : src or dest null:"+source_properties_id+" "+dest_properties_id);
                                //for (String s:stri_array) println(s);
                            }
                            Boolean notDeletabled=false;
                            if (prop.isSet("notDeletabled")) notDeletabled=prop.getBoolean("notDeletabled");
                            if (source!=null&&dest!=null) addConnector(source, dest, "",notDeletabled);
                            st="";
                        }

            //if (workflow.simplegraph) workflow.workflow.outputExecution();            
            force_redraw=true;
			redraw();
            return true;
        
    }

/**
 * This is a special function for the workflow_preview
 * This create the obj without destroying other object
 * @param obj
 */
public workflow_object createObjectWorkflow(workflow_properties obj) {
    workflow_object tmp=createObject(obj);    
    return tmp;
}

/**
 * Class used to put new object on the workflow
 * @param object_name (String)
 */
public workflow_object createObject(workflow_properties obj, int x, int y) {
    //System.out.println(obj);
    setChanged(true);
    //--Set properties x and y
    obj.put("x", x);
    obj.put("y", y);
    //--Switch for the differents object...
    workflow_object tmp=null;	
    if (!obj.get("ObjectType").equals(workflow_properties.NotSet)) {
       
        // CASE 2: Else, we create objects
        if (obj.get("ObjectType").equals("For")||obj.get("ObjectType").equals("While")) {
            //tmp=new workflow_object_aggregator(obj,x, y);
        } else
        if (obj.get("ObjectType").equals("If")) {
            //tmp=new workflow_object_if(obj,x, y);
        } else
         if (obj.get("ObjectType").equals("Begin")) {
             //--Note, we only want 1 begin object
             workflow_object dummy=new workflow_object(obj,x, y);
             if (nbBeginObject()==0||workflow.isInsideAggregation(dummy)) {
                 tmp=new workflow_object_BeginEnd(obj,x, y);
             } else {
                 //if (parent!=null) {
                    //--Note: deprecated
                 //    JOptionPane.showMessageDialog(parent, "Warning! You can only have one Begin in your workflow");
                 //}
             }
        } else
            if (obj.get("ObjectType").equals("End")) {
                tmp=new workflow_object_BeginEnd(obj,x, y);
        } else
         if (obj.get("ObjectType").equals("Script")) {
            tmp=new workflow_object_script(obj,x, y);
        } else
        if (obj.get("ObjectType").equals("ScriptBig")) {
            tmp=new workflow_object_script_big(obj,x, y);
        } else
        if (obj.get("ObjectType").equals("Output")) {
             tmp=workflow.createOutput_Object(obj,x, y);
        } else
        if (obj.get("ObjectType").equals("OutputDatabase")) {
             tmp=new workflow_object_output_database(obj,x, y);
        } else
        if (obj.get("ObjectType").equals("Variable")) {
             tmp=new workflow_object_variable(obj,x, y);
        } else
        {
            //By default a Program...
            tmp=new workflow_object(obj, x, y);			
        }
        //--Finally, add to workflow        
        if (tmp!=null) workflow.add(tmp);        
    }
    return tmp;
}

/**
 * This will create the specified variable on the workflow or update it.
 * @param name
 * @param value
 * @param visible
 * @return
 */
public workflow_properties setVariable(String name, String value, Boolean visible) {
    workflow_properties tmp=null;
    //1. Find possible variable
 
    //2. No variable found in the workflow, add one...
         tmp.setName("Undefined Variable");
         tmp.put("colorMode","GREEN");
         tmp.put("defaultColor","GREEN");
         tmp.put("Output"+"Text", "True");
         tmp.put("outputType", "Text");
         tmp.put("InputAll","Connector0");
         tmp.put("Connector1Output", "True");
         //tmp.put("Connector0Conditional", "True");
         tmp.put("ObjectType", "Variable");
         //tmp.put("output_"+"variable"+"_id", id);
         tmp.put("EditorClassName","editors.VariableEditor");

    return tmp;
}

/**
 * Class used to put new object on the workflow
 * @param object_name (String)
 */
public workflow_object createObject(workflow_properties obj) {
    int x=obj.getInt("x");
	int y=obj.getInt("y");
    if (x==0&&y==0||x<0||y<0) {
        x=135;
        y=20;
    }
    return createObject(obj,x,y);
}
 

/**
 * Copy current selected object into a buffer for Copy&Paste
 */
public void copySelection() {
    //--clear selection
    CopyPaste_selection_work.clear();
    CopyPaste_selection_work_connection.clear();
    Paste_count=0;

    for (workflow_object obj:work) {
        if (obj.selected) {
            CopyPaste_selection_work.add(obj);
        }
    }
    for (workflow_connector_edge obj:work_connection) {
        if (CopyPaste_selection_work.contains(obj.getDestinationParent())||CopyPaste_selection_work.contains(obj.getSourceParent())) {
            CopyPaste_selection_work_connection.add(obj);
        }
    }
}

/**
 * Paste the previously copySelection into the workflow
 */
public void pasteSelection() {
    HashMap oldnew=new HashMap();
    CopyPaste_selection_Paste_count++;
    for (workflow_object old_object:CopyPaste_selection_work) {
        //--Create a new properties
        workflow_properties prop=old_object.getProperties();
        workflow_properties newprop=new workflow_properties();
        newprop.deserializeFromString(prop.serializeToString());
        //--Create and select object
        int x=newprop.getInt("x")+(30*CopyPaste_selection_Paste_count);
        int y= newprop.getInt("y")+(30*CopyPaste_selection_Paste_count);
        // TO DO CLipping here
        workflow_object new_object=createObject(newprop, x,y);
        new_object.selected=true;
        oldnew.put(old_object,new_object);
    }
    
    for (workflow_connector_edge obj:CopyPaste_selection_work_connection) {
            workflow_properties prop=obj.getProperties();            
            workflow_object source=oldnew.get(obj.getSourceParent());
            workflow_object dest=oldnew.get(obj.getDestinationParent());
            //--Handle case when source/dest is not in selection
            if (source==null) source=obj.getSourceParent();
            if (dest==null) dest=obj.getDestinationParent();
            //--Get the actual connector
            int source_connectorNb=obj.source.number;
            int dest_connectorNb=obj.dest.number;
             workflow_connector source_connector=source.connection[source_connectorNb];
             workflow_connector dest_connector=dest.connection[dest_connectorNb];
            if (source_connector!=null&&dest_connector!=null) {
                Boolean notDeletabled=false;
                if (prop.isSet("notDeletabled")) notDeletabled=prop.getBoolean("notDeletabled");
                workflow.addConnector(source_connector, dest_connector, "",notDeletabled);
            } 
    }    
} //--End pasteSelection

 
 
 /**
 * Function to return a unique number
 * @return a unique number 
 */
public int getHashcode() {
    Util u=new Util();
	return u.returnCount();
}

  
} //End workflow